---
title: "Tools_box"
author: "Delmotte Jean"
date: "8 juillet 2018"
output: html_document
---
A allé voir, ce site semple très complet
https://adv-r.hadley.nz/quasiquotation.html

# Package

la fonction ci dessous va installé les packages d'un vecteur (ici "packages") si il ne sont pas installé sur l'ordinateur, et si ils le sont, le package va les charger

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Fonction to install / load package if it's not here
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# usage
packages <- c("ggplot2", "plyr", "gtools", "dplyr", "ggridges", "stringr", "RColorBrewer",
              "lattice", "scales", "plotrix", "gridExtra", "reshape2", "tidyr", "randomForest",
              "cowplot")
ipak(packages)
```

# Base

## Type d'objets

### Vecteurs

Dans R un vecteur une **liste d'éléments** c'est l'un des éléments de base du language.
```{r}
# Vecteur numérique
vecteur <- c(1,25,34,58)

# Vecteur caractères
drapeau <- c("noir", "jaune", "vert")

# Vecteur vide avec la fonction vector, ici 5 fois des éléments "character" vide
vec_vide <- vector("character", 5)
vec_vide
```


### Matrices

Les matrices sont crée à partir de vecteurs et sont à deux dimensions, c'est en gros un vecteur 2D. Tous les éléments d'une matrice sont du même type.

De plus, les numéros de lignes et de colonnes sont représentés par des chiffres entre crochets : le chiffre **avant la virgule** indique le **numéro de ligne**, alors que le chiffre **après** représente **les colonnes**. Un moyen mémo pour éviter à tester h24 les 2 :

- "lignes" il y a moins de lettre donc c'est avant la virgule, et "colonne" il y a plus de lettre donc c'est après

```{r}
# Creation matrice 1, ncol précise le nombre de colonne
matrice <-matrix(c(1:15), ncol=3)

# Creation matrice 2
matrice <-matrix(c(1:15), 3)

# Creation matrice 3, le vecteur c(1:15)*100 est directement introduit dans la matrice
matrice <- matrix((1:15)*100, nrow = 3, byrow = TRUE)

# Creation matrice vide
matrice <- matrix(NA, nrow = 4, ncol = 5)
```

Remarque : L'utilisation de matrice [vide](###Créer-un-dataframe-avec-le-bon-nombre-de-colonne-et-que-celle-ci-soit-vide)peut être intéressante quand on utilise un script R dans un pipeline si on veut importer des données d'un fichier mais que celui-ci est vide, ça permet d'éviter de faire planter le pipeline si l'erreur est gérer, voir plus loin.

### Arrays

Les arrays sont crée à partir de vecteurs et sont à $n$ dimensions. La numérotation est identique à celle des [matrices](###Matrices). Les niveaux supplémentaires sont indiqué au dessus de chaque plan.

Ici nous allons créer un tableau à 3 lignes, 5 colonnes et 2 niveaux par ordre alphabétique

```{r}
array3d <- array(letters, dim =c(3,5,2))
array3d
```

Il faut s'imaginer ici, que le premier étage du cube est `,,1`, le deuxième `,,2` etc si il y en avait d'autre. le nombre de virgule designe la dimension représenté : avant virgule la première c'est les lignes (comme pour les [matrices](###Matrices)), avant la 2eme virgule c'est les colonnes (là aussi comme pour les [matrices](###Matrices)), des numéros de niveaux avant la 3eme etc..

Remarque en pratique les arrays sont pas vraiment utilisé.

## e

```{r}

```

## Génération de données avec runif()
Génère un nombre défini de données aléatoire

```{r}
Alea <- runif(50, min = 65, max = 100) # Génération des données
# vérification des 50 data
length(Alea)
min(Alea)
max(Alea)
```

## Répéter une chaine de caractère

Facile
```{r}
rep("NSI", 3)
```

Plus Funkie :

```{r}
c("Matricule", "Donneuse_C", "Donneuse_T", "Donneuse_LT", "Donneuse_B" , rep(c(rep("NSI", 3), rep("F11", 3), rep("F32", 3)), 4))
```

## Ecrire un fichier CSV à partir d'un dataframe

```{r}
# Write CSV in R
write.table(MyData, file = "MyData.csv")

# Write CSV le fichier est encore à retravailler après pb au niveau des tab etc..
#write.table(suivie_Morta, file = "/home/jean/Documents/out_R/suivie_mortalite.csv",row.names=TRUE, na="", col.names=TRUE, sep = "\t",
```

## Création d'un vecteur de date
Ici 10 jours : 

```{r}
date_manips <- c(as.Date('2018-09-26') + 0:10)
```

# Dataset : 
## Creation dataset : 
### Dataset avec des donnnées spécifié
```{r}
donnees <- data.frame(A=c(18,17,17,17,12,5,10,8), B=c(8,12,15,10,1,5,20,7), C=c(18,15,16,14,13,17,15,15))
```

### Créer un dataframe avec le bon nombre de colonne et que celle ci soit vide

Ici un dataframe de 4 lignes sur 5 colonnes

```{r}
Empty_dataframe <- data.frame(matrix(NA, nrow = 4, ncol = 5))
str(Empty_dataframe)
```

*remarque* : on peut utilisé un `length(date_manips)` au lieu d'un entier pour facilité la création [voir](###Dataframe-pour-le-suivie-de-mortalité) 

### Dataframe pour le suivie de mortalité

Lorsque

```{r}
# 
date_manips <- c(as.Date('2018-09-26') + 0:10)
jours <- paste0("Jour", as.character(0:10))
noms_bacs <- c("DATE", "C", "T", "LT", "B", as.character(0:36))
suivie_Morta <- data.frame(matrix(NA, nrow = length(noms_bacs), ncol = length(date_manips)))
str(suivie_Morta)
rownames(suivie_Morta) <- noms_bacs
colnames(suivie_Morta) <- jours
suivie_Morta[1,] <- as.character(date_manips)
suivie_Morta
```
## Nettoyage de données

aide : http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-munging/replacing-values.html

### Appliqué le basename dans R

```{r}
filepath <- "~/Document/analyse_R/Nom_fichier.csv"
sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(filepath))
```

### Changé une ligne 

```{r}
abondance_brut <- data.frame(gene_un=c(178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(69,70,65,68, 70, 71, 67, 63, 80))
abondance_brut
```

```{r}
name_exp <- c("~/Document/analyse_R/Nom_fichier.csv", "~/Document/analyse_R/Nom_fichier1.csv") # crétion d'un vecteur qui aura le basename des manips
abondance_brut[1,] <- name_exp
str(name_exp)
Transition_vec <- c()

for (l in abondance_brut[1,]) {
  l <-sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(l))
  Transition_vec <- rbind(Transition_vec, l)
}
abondance_brut[1,] <- Transition_vec
abondance_brut
```


### Changé les valeurs d'une colonnes selon une condition

Ici la contidtion c'est si dans la colonne des valeurs sont égale à 10 alors on remplace par 240
```{r}
abondance_brut$temps <- ifelse(test=abondance_brut$temps == 10, 240, abondance_brut$temps)
```

### Supprimer Des lignes

```{r}
donnees <- data.frame(A=c(18,17,17,17,12,5,10,8), B=c(8,12,15,10,1,5,20,7), C=c(18,15,16,14,13,17,15,15), D=c("A", "A", "A", "A", "B", "B", "B", "B"))
donnees
```

```{r}
donnees <- donnees[ !(donnees$D %in% "B"),]
donnees
```

**Remarque** : On peut remarquer que il y a une virgule `"B"),]` pour spécifier qu'il s'agit d'enlever des lignes

### Supprimer Des colonnes

```{r}
# Basique
x.sub6 <- x.df[, 4]
first_QC <- first_QC[c(-1,2),] # 2 col
# avec un range
QC <- raw_QC[, seq(0, ncol(raw_QC), 4)]

donnees
```

### Transposer des données

```{r}
df.aree <- t(df.aree)
```

### Transformer les données du format long au format court

https://www.listendata.com/2016/01/transpose-data-in-r.html


### Faire des sous ensemble

```{r}
which(letters %in% c("a", "x")) 
subset(df,grepl("t2",df$Command) & grepl("pd",df$Command)) 
```

### Rechercher une valeur spécifiquement dans un df
Ici on recherche  à renvoyer la ligne ou il y a la valeur 42530 dans la colonne `pos`

```{r}
Fichier_A[Fichier_A[, "pos"] == 42530,]
```

### Afficher la plus petite valeurs d'un dataframe

# Column name with minimum value
names(df)[which.min(apply(df,MARGIN=2,min))]

# Row name with minimum value
rownames(df)[which.min(apply(df,MARGIN=1,min))]

### Renvoyer le noms de la colonne du max dans une ligne

colnames(transi)[apply(transi,1,which.max)]

## Changé les chaines de caractère dans une colonne d'un dataframe

### A la base

```{r}
file[ file == "./." ] <- "ab"
```


### Avec gsub

```{r}
file <- gsub("./.","ab",file, fixed = TRUE)
```

# Statistiques

Post très utile avec les visualisations des p-values : https://www.r-bloggers.com/add-p-values-and-significance-levels-to-ggplots/
# plot :

## Plotter uniquement un sous ensemble de données avec ggplot

### Avec le subseting pour 1 choses d'une colonne 

Typiquement les contrôles d'une manip

voir : https://datacarpentry.org/dc_zurich/R-ecology/05-visualisation-ggplot2.html

#### 1. basique
```{r}
ggplot(subset(surveys_complete, species_id == "DS"),
       aes(x = weight, y = hindfoot_length, colour = species_id)) +
  geom_point(alpha = 0.3,  position = position_jitter()) + stat_smooth(method = "lm") +
  ylim(c(0, 60))
```
#### 2. Avec grepl

```{r}
#ggplot(subset(surveys_complete, species_id %in% c("DO", "DM", "DS") & sex %in% c("F", "M")),
difference_polym_filtred_Med <- ggplot(subset(difference_filtration, grepl("M",difference_filtration$env)), aes(x = time, y = polym)) + 
  geom_point(aes(col = fam), position = position_jitter()) +
  scale_colour_manual(values = myColors) +
  theme(axis.line = element_line(colour = "Black", size = 0.05)) +
  scale_y_continuous(breaks=seq(0,(max(second_QC$polym)*1.33), 10)) + #ajuster le max ici
  xlab("Sample") + 
  ylab("Total of polymorphisms")
```

### Avec le subsetting de chose dans 2 colonnes différente du dataframe

== Manque le basique 

#### 2. Avec grepl

Le tricks est vraiment ici : `subset(difference_filtration, grepl("A",difference_filtration$env) & grepl("I",difference_filtration$cond)` ou il faut faire un *and* (i.e. `&` ) avec les 2 fonction grep

```{r}
difference_polym_filtred_Atl <- ggplot(subset(difference_filtration, grepl("A",difference_filtration$env) & grepl("I",difference_filtration$cond)), aes(x = time, y = polym)) + 
  geom_point(aes(col = fam), position = position_jitter()) +
  scale_colour_manual(values = myColors) +
  theme(axis.line = element_line(colour = "Black", size = 0.05)) +
  scale_y_continuous(breaks=seq(0,(max(second_QC$polym)*1.33), 10)) + #ajuster le max ici
  xlab("Sample") + 
  ylab("Total of polymorphisms")
```

## Stripchart
### Intéret
- Le stripchart est un graphique qui permet de montré **chaque point individuel de données**, et ce avec plusieurs échantillons par exemple (chacun sur une ligne). ce type de graphique est dit **exploratoire**, Il  permet  en  particulier  de  **déceler  les  erreurs  de saisie**  dans  les  fichiers  (les  points  aberrants  du  type  "virgule  oubliée"  sautent  aux  yeux). Surtout,  ce  type  de  figure  a  le  grand  mérite  de  vous  obliger  à **regarder  vos  données individuelles**  et  donc  à  ne  jamais  oublier  leur **variabilité**.

- Tips : lorsqu'il y a beaucoup de données, il vaut mieux  utiliser  des  symboles  "ouverts".  Leur  empilement  noircit  alors  le  fond  graduellement, en  vous  donnant une  bonne  idée  de  la densité  des  individus  selon  la  zone  du  graphe, autrement dit vous accédez visuellement à la notion statistique de **densité de probabilité**.

### Script

#### Natif

Notont l'utilisation de `vertical=TRUE` pour mettre orienté les bars et `method="jitter"` pour ne pas caché les valeurs identique les unes sous les autres.

```{r}
donnees <- data.frame(gene_un=c(185,178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(82,69,70,65,68, 70, 71, 67, 63, 80), souris=c("wt","wt","wt","m","m","wt","wt","m","m","m"))
donnees

stripchart(gene_un ~ souris, data = donnees,
           main = "stripchart de l'expression génique souris wt contre les souris mutante",
           xlab = "touris", ylab = "Gene expression",
           col = c("red", "green"),
           vertical=TRUE)
```


#### Avec ggplot2

Pour plus d'information allé voir : http://www.sthda.com/french/wiki/ggplot2-stripchart-jitter-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees (mean, legende etc..)

```{r}
donnees <- data.frame(gene_un=c(185,178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(82,69,70,65,68, 70, 71, 67, 63, 80), souris=c("wt","wt","wt","m","m","wt","wt","m","m","m"))
donnees
donnees$souris <- as.factor(donnees$souris)

library(ggplot2)
# Stripcharts basiques
ggplot(donnees, aes(x=souris, y=gene_un)) + 
  geom_jitter(position=position_jitter(0)) # permet de séparer sur le coté, 0 pour une colonne et >0 pour plus distribué les points
```


## Lignes sur un plot

### Intéret
Permet de mettre en évidence la moyenne ou des droites de régression différentes
### Script

```{r}
donnees <- data.frame(gene_un=c(185,178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(82,69,70,65,68, 70, 71, 67, 63, 80), souris=c("wt","wt","wt","m","m","wt","wt","m","m","m"))
donnees
overall_mean <- mean(donnees$gene_un)

p <- ggplot(donnees, aes(x=souris, y=gene_un, color=souris)) + 
  geom_jitter(position=position_jitter(0), shape=20, cex=4) # Notont le shape pour changer la forme des points
p + geom_hline(yintercept = overall_mean) # Ici il y a le code necessaire pour rajouter une ligne sur le plot (ici la moyenne)
```
Plus de détails sur :

https://ggplot2.tidyverse.org/reference/geom_abline.html


## site très utile
https://stats.stackexchange.com/questions/21370/how-can-i-draw-a-boxplot-without-boxes-in-r
https://sites.google.com/site/rgraphiques/realiser-des-graphiques-avec-le-logiciel-r/les-graphiques
Pour de joli figure -> https://satijalab.org/seurat/visualization_vignette.html
pour la visualisation et des subset de données -> https://datacarpentry.org/dc_zurich/R-ecology/05-visualisation-ggplot2.html

Formule de math classique :
https://gist.github.com/derekmcloughlin/896da22518ef2f3d81b0

## ggplot2
il est nécessaire d'installer le package ggplot2 pour utiliser le code dessous

## par defaut

A ajouté dans les manip de dataframe

Reorder des colonnes dans un dataframe, ici on met la 12eme colonne du dataframe à la place de la 1er
```{r}
suivie_Morta <- suivie_Morta[,c(12,1:11)]
```

## Manathan plot 
http://www.gettinggeneticsdone.com/2014/05/qqman-r-package-for-qq-and-manhattan-plots-for-gwas-results.html

## Multiple plot 

https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html

https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html via cowplot

```{r}
# avec grid
grid.arrange(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl, nrow = 1)
# avec cowplot
plot_grid(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl,
          labels = c("A", "B", "C"),
          nrow = 1, ncol = 1,
          align = "h")

# avec ggpubr
figure <- ggarrange(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl + font("x.text", size = 10),
                    ncol = 1, nrow = 1)
figure
# avec gtable
library(gtable)
g1 <- ggplotGrob(polym_raw_Atl)
g2 <- ggplotGrob(polym_dif_Atl)
g3 <- ggplotGrob(polym_filt_Atl)
g <- rbind(g1, g2, g3, size = "first")
g$widths <- unit.(g1$widths, g2$widths, g3$widths)
grid.newpage()
grid.draw(g)

plot(polym_filt_Atl)
```


## Comparer visuellement plusieurs graphique dans le cadre de l'exploration de données

Très utile on peut passé d'un graph à l'autre comme si il y avait une UI

```{r}
# avec ggpubr
figure <- ggarrange(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl + font("x.text", size = 10),
                    ncol = 1, nrow = 1)
figure
```

# Rmarkdown

Sur le markdown : 

https://bookdown.org/yihui/rmarkdown/html-document.html#section-numbering

http://larmarange.github.io/analyse-R/rmarkdown-les-rapports-automatises.html

## loop sur des fichier Rmarkdown avec des arguments et des output file spécifique


```{bash}
for dir in ~/Documents/resultats_pysamstats/pysamsatats_divoshv1/*AF11-I-T48*/
do
    expe=${dir%*/}
    echo ${expe##*/}
    files=(`ls ${dir}*_aln_PysamStat_var_raw.txt`)
    params="A='${files[0]}',B='${files[1]}',C='${files[2]}', d='30', n='${expe##*/}'" 
    #Rscript -e "rmarkdown::render('~/Documents/divohsv1/analyse_fichier_pysamstats.Rmd', params=list(${params}))"
    Rscript -e "rmarkdown::render('~/Documents/divohsv1/analyse_fichier_pysamstats.Rmd', params=list(${params}),output_file = '${expe##*/}.html', output_dir = '/home/jean/Documents/resultats_pysamstats/')"
done
```

