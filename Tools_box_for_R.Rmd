---
title: "toolkits"
author: "Delmotte Jean"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

# Introduction

Cette article est un **support** réunissant plusieurs éléments indispensable pour travailler avec R, il comprends les bases indispensables du language, de nombreux "tips" qui sont très utile pour les analyses (changer des caractère en numérique par exemple) et les visualisations avec une courte explication de leurs utilisations. Pour le moment le 14/11/2018, l'article n'est pas encore terminé, de plus, tout retour (bon ou mauvais) est interessant à prendre.

Pour allé plus loins une fois que les base sont comprise je vous invite à voir le [site](https://sites.google.com/site/rgraphiques/home) réalisé par Antoine Massé (Université de Bordeaux). Ce site en français explique clairement comment prendre en main R et présente de nombreux exemple et exercice.

# Navigation

Il ne s'agit pas ici d'une table des matières exhaustive de tout le contenue de l'article (ça serait long et chiant à lire). L'idée ici est plutôt de mettre les grandes lignes directrice de l'article. C'est pourquoi il est encouragé lorsque l'on s'intéresse à une des partie de continuer à naviguer.

* [La base](#la-base)
    * [Type d'objets sur R](#type-d'objets-sur-r)
        * [Objet simple](#objet-simple)
        * [Vecteurs](#vecteurs)
        * [Matrices](#matrices)
        * [Arrays](#arrays)
        * [Les Dataframes](#les-dataframes)
        * [Les listes](#les-listes)
        * [Les facteurs](#les-facteurs)
        * [Les Tables](#les-tables)
    * [Génération de données avec runif()](#génération-de-données-avec-runif())
    * [Ecrire un fichier CSV à partir d'un dataframe](#ecrire-un-fichier-csv-à-partir-d'un-dataframe)
    * [Création d'un vecteur de date](#création-d'un-vecteur-de-date)
    * [Gérer les erreurs](#gérer-les-erreurs)
* [Packages](#packages)
    * [Utiliser plusieurs packages](#utiliser-plusieurs-packages)
* [Dataset](#dataset)
    * [Creation par importation de fichier](#creation-par-importation-de-fichier)
        * [Importation de tableaux](#importation-de-tableaux)
        * [Description d'un objet de données](#description-d'un-objet-de-données)
* [Data-mining](#data-mining)
    * [Analyse d'un objet de données](#analyse-d'un-objet-de-données)
    * [Modification et ou nettoyage des données](#modification-et-ou-nettoyage-des-données)
        * [Opération sur un vecteur](#opération-sur-un-vecteur)
        * [Opération sur les matrices](#opération-sur-les-matrices)
        * [Opération sur les dataframes](#opération-sur-les-dataframes)
          * [Enlever une ligne d'un dataframe](#enlever-une-ligne-d'un-dataframe)
          * [Enlever des lignes d'un dataframe par position](#enlever-des-lignes-d'un-dataframe-par-position)
          * [Enlever des lignes d'un dataframe par condition](#enlever-des-lignes-d'un-dataframe-par-condition)
          * [Forcer la transformation de caractère à numérique](#forcer-la-transformation-de-caractère-à-numérique)
        * [Manipuler un chaine de caractère](#manipuler-un-chaine-de-caractère)
* [Statistiques](#statistiques)
    * [Statistique descriptives](#statistique-descriptives)
* [Plot](#plot)
    * [Stripchart](#stripchart)
    * [Boxplot](#boxplot)
    * [Histogramme](#histogramme)
    * [Barplot](#barplot)
    * [Mos](#mos)
    * [Venn Diagram](#venn-diagram)
    * [Manathan plot ](#manathan-plot-)
    * [Plotter uniquement un sous ensemble de données avec ggplot](#plotter-uniquement-un-sous-ensemble-de-données-avec-ggplot)
    * [Lignes sur un plot](#lignes-sur-un-plot)
    * [Multiple plot ](#multiple-plot-)
      * [Comparer visuellement plusieurs graphique dans le cadre de l'exploration de données](#comparer-visuellement-plusieurs-graphique-dans-le-cadre-de-l'exploration-de-données)
- [Rmarkdown](#rmarkdown)
    * [Référence document de sortie](#référence-document-de-sortie)
    * [Lancer un fichier Rmd avec des arguments](#lancer-un-fichier-rmd-avec-des-arguments)



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Fonction to install / load package if it's not here
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# usage
packages <- c("ggplot2", "plyr", "gtools", "dplyr", "ggridges", "stringr", "RColorBrewer",
              "lattice", "scales", "plotrix", "gridExtra", "reshape2", "tidyr", "randomForest",
              "cowplot", "RAM", "VennDiagram", "datasets")
ipak(packages)
```

___

# La base

## Type d'objets sur R

Les objets les plus importants à retenir sont les [vecteurs](#vecteurs), les [dataframes](#dataframes) et les [matrices](#matrices) toutefois dans un but pédagogique tout les éléments sont expliqué !

### Objet simple

Il s'agit d'une variable qui code pour 1 seul chose

```{r simple}
Truc_simple <- 486
Truc_simple
```


### Vecteurs

Dans R un vecteur une **liste d'éléments** c'est l'un des éléments de base du language. Il est en **une dimension**.
```{r vecteur}
# Vecteur numérique
vecteur <- c(1,25,34,58)
vecteur

# Vecteur caractères
drapeau <- c("noir", "jaune", "vert")
drapeau

# Vecteur vide avec la fonction vector, ici 5 fois des éléments "character" vide
vec_vide <- vector("character", 5)
vec_vide
```


### Matrices

Les matrices sont crée à partir de vecteurs et sont à **deux dimensions**, c'est en gros un vecteur 2D. Tous les éléments d'une matrice sont du même type.

De plus, les numéros de lignes et de colonnes sont représentés par des chiffres entre crochets : le chiffre **avant la virgule** indique le **numéro de ligne**, alors que le chiffre **après** représente **les colonnes**. Un moyen mémo pour éviter à tester h24 les 2 :

- "lignes" il y a moins de lettre donc c'est avant la virgule, et "colonne" il y a plus de lettre donc c'est après

```{r matrices}
# Creation matrice 1, ncol précise le nombre de colonne
matrice <-matrix(c(1:15), ncol=3)
matrice

# Creation matrice 2
matrice <-matrix(c(1:15), 3)
matrice

# Creation matrice 3, le vecteur c(1:15)*100 est directement introduit dans la matrice
matrice <- matrix((1:15)*100, nrow = 3, byrow = TRUE)
matrice

# Creation matrice vide
matrice_vide <- matrix(NA, nrow = 4, ncol = 5)
matrice_vide
```

Remarque : L'utilisation de matrice [vide](###Créer-un-dataframe-avec-le-bon-nombre-de-colonne-et-que-celle-ci-soit-vide)peut être intéressante quand on utilise un script R dans un pipeline si on veut importer des données d'un fichier mais que celui-ci est vide, ça permet d'éviter de faire planter le pipeline si l'erreur est gérer, voir plus loin.

### Arrays

Les arrays sont crée à partir de vecteurs et sont à $n$ dimensions. La numérotation est identique à celle des [matrices](###Matrices). Les niveaux supplémentaires sont indiqué au dessus de chaque plan.

Ici nous allons créer un tableau à 3 lignes, 5 colonnes et 2 niveaux par ordre alphabétique

```{r arrays}
array3d <- array(letters, dim =c(3,5,2))
array3d
```

Il faut s'imaginer ici, que le premier étage du cube est `,,1`, le deuxième `,,2` etc si il y en avait d'autre. le nombre de virgule designe la dimension représenté : avant virgule la première c'est les lignes (comme pour les [matrices](###Matrices)), avant la 2eme virgule c'est les colonnes (là aussi comme pour les [matrices](###Matrices)), des numéros de niveaux avant la 3eme etc..

Remarque en pratique les arrays sont pas vraiment utilisé.

### Les Dataframes

Les Dataframes sont une série de vecteurs colonnes, ils sont créer e à partir de plusieurs vecteurs ou encore de matrices. Les **colonnes sont des variables** systématiquement . Une colonnes porte des noms en `X` par defaut, ou le noms du vecteurs qui deviendra la colonne. Le type de variable reste le même systématiquement dans une colonne (une colonne contient que des numériques, que des chaînes de caractère par exemple). 

*Remarque* : dans le cas de chaîne de caractère, les guillemets sont enlevé car par defaut le contenue de la colonne est considérer comme des facteurs.

```{r dataframes}
donnees <- data.frame(A=c(18,17,17,17,12,5,10,8), B=c(8,12,15,10,1,5,20,7), C=c(18,15,16,14,13,17,15,15))
donnees
```

#### Créer d'un dataframe vide de dimension spécifique

Ici un dataframe de 4 lignes sur 5 colonnes

```{r dataframe_empty}
Empty_dataframe <- data.frame(matrix(NA, nrow = 4, ncol = 5))
str(Empty_dataframe)
```

*remarque* : on peut utilisé un `length(date_manips)` au lieu d'un entier pour facilité la création [voir](###Dataframe-pour-le-suivie-de-mortalité) 

### Les listes

Les listes (séries de données) sont créées à partir d'objet de tout types : simples, vecteurs, matrices, arrays, dataframes etc.. Dans les liste chaque compartiment est appelé par un **numéro entre double crochet**.


```{r listes}
# Creation liste simple avec les éléments vue précédement
liste_1 <- list(donnees, matrice, vecteur)
liste_1

# Creation liste vide de taille non nulle
liste_vide <- vector("list",1)
liste_vide
```



### Les facteurs

Le facteur est un type de qualité qui ce déplace en velo et distribue le courri.. Non c'est un type de **vecteur adapté au variable qualitatives** Il est créé à partir d'un vecteur de caractère.

```{r facteur_1}
# Creation d'un vecteur de caractère
distribution_courrier <- rep(c("rapide", "moyen", "fort"), c(1,2,3))
distribution_courrier
# Creation d'un facteur a partir du vecteur - 1
laposte <- factor(distribution_courrier)
laposte
```

- On peut observer la différence entre le vecteur `distribution_courrier` et le facteur `laposte` : pas de guillemets et presence de **Levels**.

La fonction `factor()` considère les caractères comme les **classes d'une variable qualitative**. Dans "Levels" elle indique les différentes classes (par ordre alphabétique lorsqu'elle est appliqué sur un vecteur de caractères). Elle est très pratique pour la contingence (i.e. l'étude des effectifs dans les différentes classes d'une variable qualitative).

L'une des particularité des facteurs est que **les éléments sont enregistré en temps que chiffres** de sorte que un chiffre correspond à un niveau (i.e. "Levels"). Il est donc possible de créer un facteur à l'aide des arments `levels` et `labels` :

```{r facteur_2}
# Creation d'un facteur en utilisant les levels et les labels - 2
distribution_courrier <- factor(c(5,0,10,5,5,0), levels = c(0,5,10), labels = c("rapide", "moyen", "fort"))
distribution_courrier
```

- On peut observer que pour `distribution_courrier` les "Levels" qui indique les différentes classe, sont affichés par ordre d'écriture dans labels et non plus par ordre alphabétique comme précédemment.

Pour finir on peut ordonner les variables (ce qui en fait des variable qualitatives ordinales) en ajoutant `ordered = TRUE`.

```{r facteur_3}
# Creation d'un facteur en utilisant les levels et les labels - 3
distribution_courrier <- factor(c(5,0,10,5,5,0), levels = c(0,5,10), labels = c("rapide", "moyen", "fort"), ordered = TRUE)
distribution_courrier
```

- On peut observer que pour `distribution_courrier` les "Levels" qui indique les différentes classe, sont affichés avec un ordre signalé par les chevrons `<`.

### Les Tables

Une table correspond à un **tableau de contingence** (comptage d'effectifs). Elle est créée à partir de facteurs, mais aussi de vecteurs ou de matrices de caractère (Dans ce cas les **veteurs** doivent impérativement avoir **le même nombre d'éléments**). Les lignes  et les colonnes prennent le nom de chaque classe (facteur) ou de chaque caractère (vecteur ou matrices). Elle peut être de dimension supérieur à 2 (plus de 2 facteurs ou vecteurs utilisé).

```{r tables}
# Creation d'une table à partir d'un facteur
distribution_courrier <- factor(c(5,0,10,5,5,0,0,0,5,10,0,10,5,10,10,10), levels = c(0,5,10), labels = c("rapide", "moyen", "fort"), ordered = TRUE)
distribution_courrier
tableau_1 <- table(distribution_courrier)
tableau_1

# Creation d'une table à partir de 2 vecteurs
distribution_courrier <- rep(c("rapide", "moyen", "fort"), c(1,2,3)) # 6 elements
noms_facteurs <- c("Pierre", "Paul", "Jacques","Pierre", "Paul", "Jacques") # 6 elements
tableau_2 <- table(distribution_courrier, noms_facteurs)
tableau_2

# Creation d'une table à l'aide d'un dataframe
laposte <- data.frame(distribution_courrier, noms_facteurs)
laposte
tableau_3 <- table(laposte)
tableau_3
# Les 3 ligne font la meme chose
xtabs(~ distribution_courrier + noms_facteurs,laposte)
xtabs(~.,laposte)

# Creation d'une table vide (pour la remplir au fur et a mesure)
tableau_vide <- matrix(nrow = 2,ncol = 4)
tableau_vide <- as.table(tableau_vide)
tableau_vide
```

## Génération de données avec runif()
Génère un nombre défini de données aléatoire

```{r}
Alea <- runif(50, min = 65, max = 100) # Génération des données
# vérification des 50 data
length(Alea)
min(Alea)
max(Alea)
```



## Ecrire un fichier CSV à partir d'un dataframe

```{r}
# Write CSV in R
write.table(donnees, file = "MyData.csv")

# Write CSV le fichier est encore à retravailler après pb au niveau des tab etc..
#write.table(suivie_Morta, file = "~/Documents/out_R/suivie_mortalite.csv",row.names=TRUE, na="", col.names=TRUE, sep = "\t",
```

## Création d'un vecteur de date
Ici 10 jours : 

```{r}
date_manips <- c(as.Date('2018-09-26') + 0:10)
date_manips
```
## Gérer les erreurs

from : http://mazamascience.com/WorkingWithData/?p=912

La fonction suivante lit un fichier avec `read.table()`. Si ça échoue, par exemple lorsque le fichierest vide (généré dans un pipeline par exemple), ça va mettre une matrice vide à la place.

```{r}

basePath <- "/export/home/delmotte/Documents/Divoshv1_Resultats/F11_AvsM_comparaison/"
read.file <- function (file.name) {
  fichier <- try(read.table(file.name, header = FALSE, dec = ".", sep = "\t", stringsAsFactors=F))
  if (class(fichier) == "try-error") {
    cat("Caught an error during read.table(), file can be empty, using matrice.\n")
    fichier <- data.frame(matrix(NA, nrow = 0, ncol = 6)) # problem si le fichier est vide
  }
  fichier
}

private_C <- read.file(paste0(basePath, "private_AF11-I-T48_intersec_3_replicats.csv"))
private_C
```


___

# Packages

R bénéficie d'une très large communauté, énormement de package sont créé, amélioré. Certain comme `ggplot2` sont des classiques incontournables !
Pour installer un package il faut :

- Le télécharger au bonne endroit
- Le charger dans la mémoire pour pouvoir l'utiliser dans la mémoire

Heureusement, j'ai une [fonction](#utiliser-plusieurs-packages) très utile qui s'occupe de tout et marche dans 99% des cas !

## Télécharger et installer un package

La commande `install.packages()` permet d'installer les packages (d'ou son nom). Il faut mettre le nom du package entre `""`.

```
install.packages("ggplot2")
```
Remarque : si vous êtes sous linux (c'est que vous êtes probablement quelqu'un de bien) et que ça ne fonctionne pas, c'est qu'il faut un accès root. Dans ce cas vous pouvez voir l'article [ici](https://www.r-bloggers.com/installing-r-packages/)

## Charger un package

Toujours avec l'exemple de `ggplot2` 
```
library(ggplot2)
```

## Utiliser plusieurs packages

Lorsque l'on a plusieurs packages il intéressant de ne pas faire 1000x `install.packages` et `library` surtout si certain sont pas encore installé. C'est pour ça que la fonction `ipak()` est très pratique. Pour l'utiliser c'est extremement simple :

- 1) On charge la fonction `ipak()` 
- 2) On affecte un vecteur, nommé `packages` contenant le noms de tout les packages à utiliser entre `""` et séparé par des virgules `,`
- 3) On éxécute la fonction sur le vecteur, remarque il faut attendre un certain temps que tout les packages ce charge.


```{r ipak}
# Fonction to install / load package if it's not here
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# usage
packages <- c("ggplot2", "knitr")
ipak(packages)
```

Remarque : J'utilise cette fonction dans le `{r setup, include=FALSE}` en amont de mes scripts, voir la partie [Rmarkdown](#rmarkdown) pour plus de détails
___

# Dataset

Pour créer/construire un dataset, on peut faire comme indiqué pour les [Dataframes](#les-dataframes) ou alors on peut les importer.

## Creation par importation de fichier

Le logiciel R permet d'importer des données existant dans différents formats comme les CSV, les TXT etc.. Il est conseillé de d'avoir les **variables en colonnes** et les **individues sur les lignes**.

Remarque sur les fichier en excel : il faut utiliser les chiffres décimaux avec un **point** et pas un virgule.

### Importation de tableaux

Pour créer un dataframe appelé `df` à partir du fichier `USArrests.csv` utilisé dans l'exemple de l'article sur la clusterisation.

- `header = TRUE` car la 1er ligne du fichier est le nom de colonne
- `dec = "."` car les décimals ne sont pas des virgules mais des points
- `stringsAsFactors=F` car si il y a des observations ce ne sera pas forcément des caractères




```{r importation_dataframe}
df <- read.table("~/Documents/propan2one.github.io/datas/USArrests.csv", header = TRUE, dec = ".", sep = ",", stringsAsFactors=F)
rmarkdown::paged_table(df)
```

On remarque bien que :

- Le fichier à récupérer est un chaine de caractère contenant le chemin `~/Documents/propan2one.github.io/datas/` et le nom du fichier `USArrests.csv`.

- Comme il s'agit d'une chaine de caractère on peut facilement **appliquer les fonctions/méthodes** qui leurs sont associés. Par exemple la fonction `paste()` qui permet de coller 2 chaines de caractère, ce qui si l'on stocke le chemin dans un variable permet d'importer plein de fichiers plus facilement.

- L'argument `stringsAsFactors` permet de préciser que les chaines de caractères du tableau ne doivent pas être importer au format "factor" (qui est par défaut).

Petit point pour les gens utilisant **Windows** le chemin est noté différement :

- Il y a un `C:` en amont

- Les slashs sont dans l'autre sens, au lieu d'être comme ça `/` ils sont `\`(touche -> Alt Gr + 8)

Il est possible d'importer un nombre de ligne défini :

- Soit avec l'argument `skip` qui permet de préciser le nombre de lignes à **éliminer**.

- Soit avec l'argument `nrows` qui permet de préciser le nombre de lignes à **importer**.
Importer un nombre de ligne défini peut être utile lorsque l'on souhaite faire de la mise au point d'un gros dataframe pour le réduire.

### Importation de plusieurs fichier dans le même dossier en utilisant des regex

```{r}
import_replicats <- function(famille){
  parm <- lapply(Sys.glob( paste0("~/Documents/resultats_pysamstats_JEAN/pysamsatats_divoshv1/",famille,"/*.txt") ), read.file)
  return(list(parm[1], parm[2], parm[3]))
}

AF11_T48 <- import_replicats("AF11-I-T48")
replicat1 <- as.data.frame(AF11_T48[1])
replicat2 <- as.data.frame(AF11_T48[2])
replicat3 <- as.data.frame(AF11_T48[3])
```


### Importation de vecteur

On peut créer un objet vecteur de caractères appelé `vect_import` à partir d'un fichier texte.

```{r scan}
vect_import <- scan("~/Documents/propan2one.github.io/datas/donneAimporter.txt", what = "")
vect_import
```

Remarque :

- La fonction `scan()` import par défaut des chiffres, or si il y a des caractères il faut ajouter l'argument `what()=""`.

- On peut aussi importer des [listes](#les-listes) avec `scan()`.

- L'importation de vecteur n'est pas très commune contrairement aux dataframes.

## Importation de dataset présent dans des packages

Il existe des packages ou sont regrouper des données classiquement utiliser dans les exercices / cours de datasciences/bio-informatique.

```{r iris}
library(datasets)
head(iris)
```

Ici il s'agit du package `datasets` on l'on retrouve le jeu de donnée "iris".

## Visualisation des données importés

Pour visualiser les données importés, on utilise la fonction `View()` 

```
View(iris)
```

___

# Data-mining

Le terme de *data-mining* désigne l'exploration des données, il s'agit ici d'analyser les données de différentes manières, en les transofrmants, en faisant des sous ensembles, en établissant des liens etc..
La première étape du data-mining est donc la description d'un objet de données.

## Description d'un objet de données

Un objet qui contient des données est caractériser par : 
- Le nombre de d'éléments qui sont présent
- La nature de ces éléments

### Taille d'un objet

Pour connaitre la taille d'un objet on utilise la fonction `length()`

```{r taille}
length(Truc_simple)
length(vecteur) # nombres d'élément du vecteur
length(donnees) # nombres de colonnes
length(matrice) # nombres d'élément présent dans la matrice
length(liste_1) # nombres de compartiment dans la liste
length(tableau_3) # nombres d'élément présent dans la table
```

### Nature de l'objet

Pour connaitre quel est la nature d'un objet, on peut utiliser la fonction `class()` ou `mode()`.

```{r nature}
class(Truc_simple)
class(vecteur)
class(donnees)
class(donnees$A) #Permet de connaitre la nature des éléménts d'une colonne du dataframe
class(matrice)
class(liste_1)
class(tableau_3)
```

## Analyse d'un objet de données

### Resumé des données

Pour avoir une idée de la distribution des données on utilise la fonction `summary()`

```{r resume}
summary(Truc_simple)
summary(vecteur) # décrit les éléments du vecteur
summary(donnees) # décrit les éléments de chaque colonnes du dataframe
summary(matrice) # décrit les éléments de chaque colonnes de la matrice
summary(liste_1) # décrit les compartiments dans la liste
summary(tableau_3) # nombres d'élément présent dans la table
```

On voit ici des éléments abordé dans la partie des [Statistique descriptives](#statistique-descriptives)

### Nombre de lignes

Pour un dataframe ou une matrice pour afficher le **nombre de lignes** présent on utilise la fonction `nrow()`

```{r}
nrow(donnees)
nrow(matrice)
```

### Nombre de colonnes

Pour un dataframe ou une matrice pour afficher le **nombre de colonnes** présent on utilise la fonction `ncol()`

```{r}
ncol(donnees)
ncol(matrice)
```

## Modification et ou nettoyage des données

Après l'importation des données il est souvent necessaire de les transformer. Bien souvent lorsqu'un objet est transformer il est necessaire **d'assigner la modification** à une variable (souvent lui même) pour conserver la modification.

```{r modif_datas}
donnees$A
# Si on modifie un objet
donnees$A*2
# Si on regarde l'objet
donnees$A # pas de modification
# En l'assignant maitenant à lui même
donnees$A <- donnees$A*2
donnees$A
```

### Opération sur un vecteur

#### Operation arithmétique sur un vecteur

On peut faire des opérations arithmétique (additionner, multiplier..) sur les éléments d'un vecteur par un nombre/variables etc..

```{r arithmetique_vec}
vecteur
vecteur*2
vecteur/2
```

#### Analyse sur un vecteur

Renvoi des booléens pour chacun des éléments d'un vecteur en fonction d'une condition. Ici on affiche pour chacune des valeurs du vecteur `vecteur` si elle sont vraiment inférieur à 30.

```{r}
vecteur < 30
```

#### Manipulation des éléments d'un vecteur

##### Extraire un élément

Il faut simplement mettre la position de l'élement à extraire, par exemple pour le 2eme éléments

```{r extract_vec_1}
vecteur[2]
```

*Remarque contrairement à la majorité des languages de programmation, sur R le comptage ne commence pas à 0*

##### Extraire un nombre d'éléments

Ici les éléments à parir de 2 à 4 du vecteur.

```{r extract_vec_2}
vecteur[c(2,4)]
```

*Remarque si on est hors du range du vecteur on aura des `NA` pris en compte*

##### Extraire des éléments selon une condition

Ici on extrait les éléments du vecteur qui sont suppérieur à 30

```{r extract_vec_3}
vecteur[vecteur>30]
```

##### Extraire des éléments selon plusieurs conditions

Ici on extrait les éléments du vecteur qui sont suppérieur à 30 mais inférieur à 50.

```{r extract_vec_4}
vecteur[vecteur>30 & vecteur<50]
```
Il est important de noter que les 2 conditions doivent être entirement écrite, et pas simplement `>30 & <50`

##### Extraire les n plus petits éléments d'un vecteur

La fonction `sort()` permet de trier les éléments par ordre croissant tandis que `1:3` (qui est le $n$ du titre) permet d'afficher les éléments 1, 2, 3. 

```{r extract_vec_5}
1:3 # exemple pour de 1 à 3
sort(vecteur)[1:3]
```

Ainsi en réalité on recrée un vecteur, `sort(vecteur)` pour lequel on affiche les éléments 1, 2, 3 comme vue [précedemment]( #extraire-un-nombre-d'éléments)

##### Retrouver l'emplacement des éléments d'un vecteur

Ici on utilise la fonction `which()` qui va parcourir le vecteur qui lui est soumis et va renvoyer tout les numéros des éléments pour lequelle la condition est vrai.

```{r which_vec}
vecteur
which(vecteur < 30) # sur le vecteur avec des chiffres

distribution_courrier <- rep(c("rapide", "moyen", "fort"), c(1,2,3))
distribution_courrier
which(distribution_courrier == "fort")
```

Le 3,4,5ème élément du vecteur `distribution_courrier` correspond à la valeur `"fort"`.

<details><summary>More informations</summary>
<p>

En réalité la fonction `which()` correspond en vrai à une **boucle for** avec une condition. En R cela donnerai 

```{r loop_conditional_more}
a <-1 # ici parce que R ne commmence pas à 0
for (i in distribution_courrier) {
  if (i == "fort") {
    print(a)
  }
  a <- a +1
}
```

Toutefois, les boucles for conditionnel ne sont pas courante sur R et sont presque systématiquement remplacer par `which()`.

</p>  
</details>

##### Remplacer des éléments d'un vecteur par autre chose

Remplacer plusieurs éléments d'un vecteur en même temps est extremement puissant, et cela peut être fait de 2 manières

###### Assignation via une condition

```{r replace_vec_1}
distribution_courrier_2 <- rep(c("rapide", "moyen", "fort"), c(1,2,3))
distribution_courrier_2
distribution_courrier_2[which(distribution_courrier_2 == "fort")] <- "lourd"
distribution_courrier_2
```

Remarque : `[which(distribution_courrier == "fort")` à pour résultat `[1] 4 5 6`. Donc c'est comme si l'on avait fait

```{r replace_vec_2}
distribution_courrier_2 <- rep(c("rapide", "moyen", "fort"), c(1,2,3))
distribution_courrier_2[c(4,5,6)] <- "lourd"
distribution_courrier_2

```

###### Test directement sur le vecteur

Ici la contidtion c'est si dans la colonne des valeurs sont égale à 10 alors on remplace par 240
```{r}
distribution_courrier_2 <- rep(c("rapide", "moyen", "fort"), c(1,2,3))
distribution_courrier_2
distribution_courrier_2 <-ifelse(test=distribution_courrier_2 == "fort", "lourd", distribution_courrier_2)
distribution_courrier_2
```

Remarque importante : cas des **données binaire**, soit l'un soit l'autre. Exemple si il y a un vectuer homme femme

```{r replace_ifelse_vec}
distribution_courrier_2 <- rep(c("homme", "femme"), c(2,2))
distribution_courrier_2

distribution_courrier_2 <- ifelse(test = distribution_courrier_2 == "homme", yes=1, no = 0)
distribution_courrier_2

# Au lieu de 
distribution_courrier_2 <- rep(c("homme", "femme"), c(2,2))
distribution_courrier_2
distribution_courrier_2[which(distribution_courrier_2 == "homme")] <- 1
distribution_courrier_2[which(distribution_courrier_2 == "femme")] <- 0
distribution_courrier_2 <- as.numeric(distribution_courrier_2)
distribution_courrier_2
```

L'avantage est de pas avoir à recoder directerment les variables car **tous les changements sont fait un même temps**.

### Opération sur les matrices

#### Operation arithmétique sur une matrice

On peut faire des opérations arithmétique (additionner, multiplier..) sur les éléments d'une matrice par un nombre/variables etc..

```{r arithmetique_matrix}
matrice
matrice*3
matrice/3

matrice_1 <- matrix(1:4, ncol = 2)
matrice_1
matrice_2 <- matrix(1:4, ncol = 2)
matrice_2
matrice_1 * matrice_2
matrice_1 %*% matrice_2
matrice_1 %o% matrice_2

```

| Operator or Function 	| Description |
| --------------------- | -----------:|
| A * B |   Element-wise multiplication    |
| A %*% B | Matrix multiplication    |
| A %o% B |    Outer product. AB'   |
| crossprod(A,B) |    A'B and A'A respectively.   |
| t(A) |    Transpose   |
| diag(x) |    Creates diagonal matrix with elements of x in the principal diagonal |
| diag(A) |    Returns a vector containing the elements of the principal diagonal   |
| diag(k) |    If k is a scalar, this creates a k x k identity matrix. Go figure.   |
| solve(A, b) |    Returns vector x in the equation b = Ax (i.e., A-1b) |
| solve(A) |    Inverse of A where A is a square matrix.    |
| ginv(A) |    Moore-Penrose Generalized Inverse of A (requires loading the MASS package).      |
| y<-eigen(A) |    `y$val` are the eigenvalues of A, `y$vec` are the eigenvectors of A  |
| y<-svd(A) |    Single value decomposition of A.   |
| R <- chol(A) |    Choleski factorization of A. Returns the upper triangular factor, such that R'R = A.    |
| cbind(A,B,...) |    Combine matrices(vectors) horizontally. Returns a matrix. |
| rbind(A,B,...) |    Combine matrices(vectors) vertically. Returns a matrix.   |
| rowMeans(A) |    Returns vector of row means. |
| rowSums(A) |    Returns vector of row sums.   |
| colMeans(A) |    Returns vector of column means.  |
| colSums(A) |    Returns vector of column sums.    |

Plus d'information : https://www.statmethods.net/advstats/matrix.html

#### Donner un nom de ligne et de colonnes au matrices

- On peut nommer un matrice

```{r names_col_row_matrix}
matrice
dimnames(matrice) <- list(c("r1", "r2", "r3"), c("c1","c2","c3","c4","c5"))
dimnames(matrice) # afficher les noms de lignes et de colonnes
matrice
```
Remarque le résultat est un objet de type `liste` avec en `[[1]]` les lignes et en `[[2]]` les colonnes

- L'avantage est de pouvoir repérer très facilement un élément dans la matrice

```{r extract_matrix}
matrice["r2", "c4"]
```

- On peut enfin changer l'un des noms de la matrice

```{r rename_col}
dimnames(matrice)[[2]][4] <- "col4"
matrice
```

### Opération sur les dataframes

L'intéret des dataframe est que chaque variable (i.e. colonne) est un vecteur, donc toute les opérations sur les vecteurs sont disponible !

#### Connaitre le nom des variables

```{r names_df}
names(donnees) # noms variable
dimnames(donnees) # noms individue et noms variables
```

#### Operation arithmétique sur un dataframes

Fort utile pour **normaliser** des données. On applique la valeur de normalisation sur l'une des colonnes du daataframe

```{r arithmetique_df}
donnees*3 # multiplication
donnees$A*3
```

#### Remplacer NA par 0

```{r}
m <- matrix(sample(c(NA, 1:10), 100, replace = TRUE), 10)
d <- as.data.frame(m)
d[is.na(d)] <- 0
```


### Opération sur les listes

Remarque sur les listes, comme R on ne peut retourner qu'un seul objet, les liste sont bien utile pour renvoyer plusieurs paramètres

#### Donner un noms aux différents éléments dans la liste

```{r names_list}
liste_1 <- list(donnees, matrice, vecteur)
names(liste_1) <- c("1st Quarter", "A_Matrix", "A Inner list")
```

#### Accéder aux éléments d'une liste

https://www.tutorialspoint.com/r/r_lists.htm

```{r}
list_data <- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),
   list("green",12.3))

# Access the first element of the list.
print(list_data[1])
```



#### Enlever une ligne d'un dataframe

On utilise alor la position, c'est à dire un nombre qui commence à 1 et finit au nombre de ligne du dataframe. ici la 3eme ligne

```{r rm_line}
donnees <- data.frame(A=c(18,17,17,17,12,5,10,8), B=c(8,12,15,10,1,5,20,7), C=c(18,15,16,14,13,17,15,15))
donnees
donnees <- donnees[-3,]
```

remarque : le `-` est la justement pour signaler qu'il faut supprimer la ligne. On stock alors le résultat dans le dataframe avec le même noms (pour économiser de la place dans la mémoire).

#### Enlever des lignes d'un dataframe par position

En réaliter il vaut mieux utiliser la fonction [subset]() à partir d'un gros dataframe, toutefois dans certain cas on doit enlever des lignes (renomme des nom de lignes à partir d'une des lignes, suppression)

Pour enlever plusieur lignes on utilise un vecteur de la même manière que avant avec le nombre qui correspond au numéro de ligne du dataframe.

```{r rm_lines_pos}
donnees
donnees <- donnees[-c(1:5),]
donnees
```

#### Enlever des lignes d'un dataframe par condition

Pour enlever plusieur lignes on peut utiliser une condition, dans l'exemple si il y a le numérique 17
```{r}
donnees
donnees <- donnees[ !(donnees$A %in% 17),]
donnees
```

Remarque :
- On peut mettre un numérique ou une chaine de caractère `"JeSuisUneChaine"`
- On peut utiliser une condition avec un vecteur, par exemple avec un `which()` tel que 

```{r}
donnees <- data.frame(A=c(18,17,17,17,12,5,10,8), B=c(8,12,15,10,1,5,20,7), C=c(18,15,16,14,13,17,15,15))
donnees
donnees <-donnees[-c(which(donnees$A == 17)),]
donnees
```


#### Forcer la transformation de caractère à numérique

```{r}
noms_lignes <- df[,1]

# Change les caractères en numérique <3
df <- data.frame(llply(df, function(x) {
  df <- str_replace_all(x, pattern="[^0-9\\.\\,-]", replacement="")
  x <- str_replace(x, pattern="\\,", replacement=".")
  return(as.numeric(x))
}))
# d'ou enregistrer les noms au préalable dans ce cas
rownames(df) <- noms_lignes
class(df)
df <- as.data.frame(df) # transformer en matrice du coup
df
```

#### Afficher la ligne avec la plus haute valeur d'un des vecteurs du dataframe

```{r}
df[which.min(df$Murder),]
df[which.max(df$Murder),]

subset(df, df$Murder == max(df$Murder))
```

### Manipuler un chaine de caractère

La gestion des chaines de caractères est très utile pour manipuler le noms de variable (en sélectionnant des éléments dedants) ou encore lors de l'écriture de fichier de sortie (coller le chemin et le nom de fichier). Ou encore pour nommer les individue d'un dataframe.

**Remarque : toute les opérations qui suivent sont suceptible d'être utiliser sur une colonne d'un dataframe** et ça c'est plutôt puissant

#### Répéter une chaine de caractère

Ici on répète 3 fois la même chaine de caractère dans un vecteur (non assigné)
```{r}
rep("Penny", 3)
```

On peut aussi faire de répétition dans des répétitions.

```{r}
c("Matricule", "Donneuse_C", "Donneuse_T", "Donneuse_LT", "Donneuse_B" , rep(c(rep("NSI", 3), rep("F11", 3), rep("F32", 3)), 4))
```

Les répétitions sont extremement utile pour créer des [dataframes](#les-dataframes). On répète des choses dans différents vecteur que l'on assemble

#### Coller deux chaines de caractère

Très utile pour gérer les chemins des fichiers notamment ou l'écriture du nom de fichier

```{r past_string}
basePath <- "~/Documents/"
noms_long <- paste0(basePath, "private_AF11-I-T48_intersec_3_replicats.csv")
noms_long
```

#### Compter les caractères d'une chaine de caractère

Très utile pour gérer les noms de variable ou de fichiers
```{r nbre_string}
nchar("private_AF11-I-T48_intersec_3_replicats.csv")
nchar(noms_long)
```


#### Extraire des caractères d'une chaine de caractère

On peut extraire un partie plus petite d'un chaine de caractère de deux manières différentes

##### En fonction de la position

Ici on va récupérer "AF11-I-T48" dans l'exemple "private_AF11-I-T48_intersec_3_replicats.csv". La partie ce trouve entre le caractère 21 et 30 de la chaine de caractère

```{r subset_string}
noms_long <- "~/Documents/private_AF11-I-T48_intersec_3_replicats.csv"
substr(noms_long, 21, 30)
```

##### En fonction d'un motif

Il s'agit ici de maitriser les **expressions régulières**.

```{r}
noms_long <- "~/Documents/private_AF11-I-T48_intersec_3_replicats.csv"
sub("^.*AF.8_.*", "", noms_long)
grep("AF", noms_long, value = TRUE)
```

Remarque : si l'on veut utiliser des caractères qui sont le même qu pour les expressions réguilère il faut utiliser la synthaxe suivante

- `\\.` pour le point

On peut identifier une expression régulière  avec :

```{r}
pat <- "^.*United State.*$"
```

- Le `^` représente le début de l'expression régulière

- `$` représente la fin

- Le `.` représente n'importe quel type de caractère 

- Le `*` défini une répétition (de 0 à n'importe)


Pour d'avantage d'information consulter : https://rstudio-pubs-static.s3.amazonaws.com/74603_76cd14d5983f47408fdf0b323550b846.html

#### Remplacer un caractères d'une chaine de caractère par autre chose

Ici on va **supprimer** le "AF" de la variable `noms_long`. On pourrait la **remplacer** par une autre chaine de caractère ou par rien en utilisant `""`.

```{r replace_carac}
noms_long <- "~/Documents/private_AF11-I-T48_intersec_3_replicats.csv"
gsub("AF11-", "GET_SCHWIFTY_", noms_long) # remplacé par une autre chaine de caractère
gsub("AF11-", "", noms_long) # Supprimer
```
#### Supprimer le chemin d'une chaine de caractère

```{r basename}
filepath <- "~/Document/analyse_R/Nom_fichier.csv"
sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(filepath))
```

#### Récupérer le nom d'une des variables en chaine de caractère

```{r}
noms_long <- "~/Documents/private_AF11-I-T48_intersec_3_replicats.csv"
Name_Var <- deparse(substitute(noms_long)) 
Name_Var
```


# Statistiques

Post très utile avec les visualisations des p-values : https://www.r-bloggers.com/add-p-values-and-significance-levels-to-ggplots/

## Statistique descriptives

Pour travailler sur un jeu de donnée R possède des fonctions pour avoir un description des données. Pour rappel, en général on organise le dataframe avec les observations/individus en ligne (rows) et les variables en colonnes (columns). Ces fonction peuvent être utilisé sur des vecteurs (et donc dataframes, matrices, etc..).

Remarque, d'autres articles vont reprendre en détails ces paramètres car ils sont incontounable en datascience.

### Moyenne

La moyenne sert à **visualiser l'ordre de grandeur d’une distribution**, une population, ou d’un échantillon.
Il s'agit de la moyenne arithmétique des varaiable quantitatives. On utilise des vecteurs pour fournir les valeurs à la fonction.

```{r mean}
mean(c(1,9,16,84,9,354,7)) # vecteurs 
donnees
mean(donnees$A) # Moyenne sur le dataframe intitulé donnees
```

Remarque : si il y a des valeurs manquantes (les `NA`) on peut les éliminer avec `na.rm = TRUE` tel que 
```{r mean_na}
mean(donnees$A, na.rm = TRUE)
```


### Mediane

La variance sert à **visualiser l'ordre de grandeur** d’une distribution, une population, ou d’un échantillon. Il s'agit de voir quelle est la valeur au centre des observations trié, ou il y a 50% des observation d'un côté, et 50% de l'autre.

```{r median}
median(donnees$A)
median(c(1,5,5,6,12,89,2390)) # 7 éléments ordonnées
median(c(12,5,89,6,5,2390,1)) # 7 éléments désordonnées
median(c(12,5,89,5,1, 6)) # 6 éléments
```

Remarque : 

- On voit bien que dans le cas de le classement, 2 éléments identique compte bien pour 2
- On voit aussi que si la taille de l'échantillon est paire, il s'agit de la demi-somme des deux valeurs du milieux

### Quantile

Les quantiles sont utile pour **visualiser l'ordre de grandeur d’une distribution**, une population, ou d’un échantillon.
La fonction `quantile()` s'applique sur les colonnes d'un dataframe, pour l'appliqué sur les lognes d'un tableau il faut utiliser la fonction `sapply()`

```{r quantile}
sapply(donnees, quantile)
```


### Max

```{r max}
sapply(donnees, max)
```


### Min


### Ecart type

Il s'agit de **l'écart type de varaiables quantitatives**. Ici les variances du dataframes `donnees` sont sur la diagonale de ma matrice.

```{r standart_deviation}
# vecteur
sd(donnees$A)
sd(donnees$B)
sd(c(1,9,16,84,9,354,7))
```

Remarque : si il y a des valeurs manquantes (les `NA`) on peut les éliminer avec `na.rm = TRUE` mais **attention**, ça va retirer tout les ligne du dataframe si il y a  ne serait-ce qu'un seul `NA` ! De plus, il existe des techniques pour estimer les valeurs manquantes (non détaillé ici).

### Variance

La variance sert à caractériser la dispersion d’une distribution, une population, ou d’un échantillon autour de sa moyenne ou son espérance.

```{r variance}
# vecteur
var(donnees$A)
var(donnees$B)
var(c(1,9,16,84,9,354,7))

# relation variance et ecart type btw
(sd(donnees$A))^2
# Dataframe
var(donnees)
```


### Co-variance

Si la variance permet d’étudier les variations d’une variable par rapport à elle-même, la covariance va permettre d’étudier les variations simultanées de deux variables par rapport à leur moyenne respective.

Il s'agit ici de la **co-variance non biaisées des varaiables quantitatives**. Ici les variances du dataframes `donnees` sont sur la diagonale de la matrice.

```{r covariance}
# vecteur
cov(donnees$A, donnees$B)


# Dataframe
cov(donnees)
```

Remarque : si il y a des valeurs manquantes (les `NA`) on peut les éliminer avec `na.rm = TRUE` mais **attention**, ça va retirer tout les ligne du dataframe si il y a  ne serait-ce qu'un seul `NA` ! De plus, il existe des techniques pour estimer les valeurs manquantes (non détaillé ici).

## Coefficient de corrélation

La calcul du coefficient de corrélation sert à caractériser la **dépendance** entre 2 variables d’une distribution, une population, ou d’un échantillon, c'est à dire la force de la relation entre 2 variables. La fonction `cor()`calcul la matrice de corrélation des variables ; il existe plusieurs methodes de calcul :

- Le coefficient de corrélation de Pearson permet de mesuré la **dépendance linéaire** entre deux variables
- Le coefficient de corrélation (ou rho) de Spearman permet de mesuré la **dépendance statistique non paramétrique** entre deux variables, utilisation du rangs des valeurs. Le calcul est basé sur les déviations.
- Le coefficient de corrélation (ou tau) de Kendall permet de mesuré la **dépendance statistique non paramétrique** entre deux variables, le calcul est basé sur des paires concordante et discordantes. Plus adapté avec des échantillons de petite taille.

```{r correlation}
cor(donnees, method = c("pearson"))
cor(donnees, method = c("kendall"))
cor(donnees, method = c("spearman"))
```
Remarque :
- Pour les deux methodes non paramétrique ($\rho$ Spearman/ $\tau$ Kendal) on peut observé que les valeurs du coefficient sont plus petite pour Kendall qu pour Speaman
- Voir l'article sur le [clustering]() pour davantage d'informations
___

# plot

p60

## Stripchart
### Intéret
- Le stripchart est un graphique qui permet de montré **chaque point individuel de données**, et ce avec plusieurs échantillons par exemple (chacun sur une ligne). ce type de graphique est dit **exploratoire**, Il  permet  en  particulier  de  **déceler  les  erreurs  de saisie**  dans  les  fichiers  (les  points  aberrants  du  type  "virgule  oubliée"  sautent  aux  yeux). Surtout,  ce  type  de  figure  a  le  grand  mérite  de  vous  obliger  à **regarder  vos  données individuelles**  et  donc  à  ne  jamais  oublier  leur **variabilité**.

- Tips : lorsqu'il y a beaucoup de données, il vaut mieux  utiliser  des  symboles  "ouverts".  Leur  empilement  noircit  alors  le  fond  graduellement, en  vous  donnant une  bonne  idée  de  la densité  des  individus  selon  la  zone  du  graphe, autrement dit vous accédez visuellement à la notion statistique de **densité de probabilité**.

### Script

#### Natif

Notont l'utilisation de `vertical=TRUE` pour mettre orienté les bars et `method="jitter"` pour ne pas caché les valeurs identique les unes sous les autres.

```{r}
donnees <- data.frame(gene_un=c(185,178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(82,69,70,65,68, 70, 71, 67, 63, 80), souris=c("wt","wt","wt","m","m","wt","wt","m","m","m"))
donnees

stripchart(gene_un ~ souris, data = donnees,
           main = "stripchart de l'expression génique souris wt contre les souris mutante",
           xlab = "touris", ylab = "Gene expression",
           col = c("red", "green"),
           vertical=TRUE)
```


#### Avec ggplot2

Pour plus d'information allé voir : http://www.sthda.com/french/wiki/ggplot2-stripchart-jitter-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees (mean, legende etc..)

```{r}
donnees <- data.frame(gene_un=c(185,178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(82,69,70,65,68, 70, 71, 67, 63, 80), souris=c("wt","wt","wt","m","m","wt","wt","m","m","m"))
donnees
donnees$souris <- as.factor(donnees$souris)

library(ggplot2)
# Stripcharts basiques
ggplot(donnees, aes(x=souris, y=gene_un)) + 
  geom_jitter(position=position_jitter(0)) # permet de séparer sur le coté, 0 pour une colonne et >0 pour plus distribué les points
```


## Boxplot

## Histogramme

## Barplot

## Mos

## Venn Diagram

Les Venn Diagram (ou diagramme logique) sont graphes montrant les **relations logiques** entre différents ensembles.

### Version basique

```{r}
A <- 2
B <-62
AB <- 31
grid.newpage()
venn.plot <- draw.pairwise.venn(A+AB, B+AB, AB,
                                category = c("noms_fichier_A", "noms_fichier_M"),
                                fill = c("blue", "red"),
                                scaled = FALSE)
grid.draw(venn.plot)
```

### Version plus avancé

Permet de visualiser la similarité entre plusieurs choses

help : https://stackoverflow.com/questions/45902376/printing-venn-diagram-after-calculating-overlap

```{r}
#library(RAM)
#library(VennDiagram)
cardiome <- letters[1:10]
superset <- letters[8:24]
overlap <- calculate.overlap(
x <- list("Cardiome"=cardiome, "SuperSet"=superset))

venn.plot <- draw.pairwise.venn(
    area1 = length(cardiome),
    area2 = length(superset),
    cross.area = length(overlap),
    category = c("Cardiome", "Superset"),
    fill = c("blue", "red"),
    lty = "blank",
    cex = 2,
    cat.cex = 2,
    cat.pos = c(180, 180),
    cat.dist = 0.05,
    cat.just = list(c(0, 1), c(1, 1))
    )
grid.draw(venn.plot)
#savePlot(filename="venndiag", type="png")
vectors <- list(Cardiome=cardiome, Superset=superset)
group.venn(vectors=vectors, label=TRUE, 
    fill = c("blue", "red"),
    cat.pos = c(180, 180),
    lab.cex=1.1)

venn.diagram(x = list(
  "Cardiome" = cardiome,
  "SuperSet" = superset
), "plot_venn")

grid.draw(venn.plot)
```


## Manathan plot 
http://www.gettinggeneticsdone.com/2014/05/qqman-r-package-for-qq-and-manhattan-plots-for-gwas-results.html

___
___


## Plotter uniquement un sous ensemble de données avec ggplot

### Avec le subseting pour 1 choses d'une colonne 

Typiquement les contrôles d'une manip

voir : https://datacarpentry.org/dc_zurich/R-ecology/05-visualisation-ggplot2.html

#### 1. basique
```{r}
ggplot(subset(USArrests, Rape >20),
       aes(x = weight, y = hindfoot_length) +
  geom_point(alpha = 0.3,  position = position_jitter()) + stat_smooth(method = "lm") +
  ylim(c(0, 60)))
```
#### 2. Avec grepl

```{r}
#ggplot(subset(surveys_complete, species_id %in% c("DO", "DM", "DS") & sex %in% c("F", "M")),
difference_polym_filtred_Med <- ggplot(subset(difference_filtration, grepl("M",difference_filtration$env)), aes(x = time, y = polym)) + 
  geom_point(aes(col = fam), position = position_jitter()) +
  scale_colour_manual(values = myColors) +
  theme(axis.line = element_line(colour = "Black", size = 0.05)) +
  scale_y_continuous(breaks=seq(0,(max(second_QC$polym)*1.33), 10)) + #ajuster le max ici
  xlab("Sample") + 
  ylab("Total of polymorphisms")
```

### Avec le subsetting de chose dans 2 colonnes différente du dataframe

== Manque le basique 

#### 2. Avec grepl

Le tricks est vraiment ici : `subset(difference_filtration, grepl("A",difference_filtration$env) & grepl("I",difference_filtration$cond)` ou il faut faire un *and* (i.e. `&` ) avec les 2 fonction grep

```{r}
difference_polym_filtred_Atl <- ggplot(subset(difference_filtration, grepl("A",difference_filtration$env) & grepl("I",difference_filtration$cond)), aes(x = time, y = polym)) + 
  geom_point(aes(col = fam), position = position_jitter()) +
  scale_colour_manual(values = myColors) +
  theme(axis.line = element_line(colour = "Black", size = 0.05)) +
  scale_y_continuous(breaks=seq(0,(max(second_QC$polym)*1.33), 10)) + #ajuster le max ici
  xlab("Sample") + 
  ylab("Total of polymorphisms")
```
## Lignes sur un plot

### Intéret
Permet de mettre en évidence la moyenne ou des droites de régression différentes
### Script

```{r}
donnees <- data.frame(gene_un=c(185,178,175,171,172 ,165, 170, 171, 164, 182 ), gene_deux=c(82,69,70,65,68, 70, 71, 67, 63, 80), souris=c("wt","wt","wt","m","m","wt","wt","m","m","m"))
donnees
overall_mean <- mean(donnees$gene_un)

p <- ggplot(donnees, aes(x=souris, y=gene_un, color=souris)) + 
  geom_jitter(position=position_jitter(0), shape=20, cex=4) # Notont le shape pour changer la forme des points
p + geom_hline(yintercept = overall_mean) # Ici il y a le code necessaire pour rajouter une ligne sur le plot (ici la moyenne)
```
Plus de détails sur :

https://ggplot2.tidyverse.org/reference/geom_abline.html


## site très utile
https://stats.stackexchange.com/questions/21370/how-can-i-draw-a-boxplot-without-boxes-in-r
https://sites.google.com/site/rgraphiques/realiser-des-graphiques-avec-le-logiciel-r/les-graphiques
Pour de joli figure -> https://satijalab.org/seurat/visualization_vignette.html
pour la visualisation et des subset de données -> https://datacarpentry.org/dc_zurich/R-ecology/05-visualisation-ggplot2.html

Formule de math classique :
https://gist.github.com/derekmcloughlin/896da22518ef2f3d81b0

Clustering
https://eranraviv.com/understanding-k-means-clustering/

## ggplot2
il est nécessaire d'installer le package ggplot2 pour utiliser le code dessous

### par defaut

A ajouté dans les manip de dataframe

Reorder des colonnes dans un dataframe, ici on met la 12eme colonne du dataframe à la place de la 1er
```{r}
suivie_Morta <- suivie_Morta[,c(12,1:11)]
```

## Multiple plot 

https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html

https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html via cowplot

```{r}
# avec grid
grid.arrange(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl, nrow = 1)
# avec cowplot
plot_grid(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl,
          labels = c("A", "B", "C"),
          nrow = 1, ncol = 1,
          align = "h")

# avec ggpubr
figure <- ggarrange(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl + font("x.text", size = 10),
                    ncol = 1, nrow = 1)
figure
# avec gtable
library(gtable)
g1 <- ggplotGrob(polym_raw_Atl)
g2 <- ggplotGrob(polym_dif_Atl)
g3 <- ggplotGrob(polym_filt_Atl)
g <- rbind(g1, g2, g3, size = "first")
g$widths <- unit.(g1$widths, g2$widths, g3$widths)
grid.newpage()
grid.draw(g)

plot(polym_filt_Atl)
```


## Comparer visuellement plusieurs graphique dans le cadre de l'exploration de données

Très utile on peut passé d'un graph à l'autre comme si il y avait une UI

```{r}
# avec ggpubr
figure <- ggarrange(polym_raw_Atl, polym_dif_Atl, polym_filt_Atl + font("x.text", size = 10),
                    ncol = 1, nrow = 1)
figure
```

# Rmarkdown

Sur le markdown : 

https://bookdown.org/yihui/rmarkdown/html-document.html#section-numbering

http://larmarange.github.io/analyse-R/rmarkdown-les-rapports-automatises.html

Stackoverflow how to make link in rmarkdown file : https://stackoverflow.com/questions/33913780/internal-links-in-rmarkdown-dont-work

## loop sur des fichier Rmarkdown avec des arguments et des output file spécifique

Lorsqu'il faut faire tourner un script sur l'ensemble des fichiers présent dans un dossier on peut (si on est sur linux/mac) faire une boucle qui va 

```{bash}
for dir in ~/Documents/resultats_pysamstats/pysamsatats_divoshv1/*AF11-I-T48*/
do
    expe=${dir%*/}
    echo ${expe##*/}
    files=(`ls ${dir}*_aln_PysamStat_var_raw.txt`)
    params="A='${files[0]}',B='${files[1]}',C='${files[2]}', d='30', n='${expe##*/}'" 
    #Rscript -e "rmarkdown::render('~/Documents/divohsv1/analyse_fichier_pysamstats.Rmd', params=list(${params}))"
    Rscript -e "rmarkdown::render('~/Documents/divohsv1/analyse_fichier_pysamstats.Rmd', params=list(${params}),output_file = '${expe##*/}.html', output_dir = '~/Documents/resultats_pysamstats/')"
done
```

## Tableaux mit en forme dans le code

https://cran.r-project.org/web/packages/gridExtra/vignettes/tableGrob.html

___

# Mise en page

## Référence document de sortie

https://stackoverflow.com/questions/29354674/knitr-with-the-biblatex-option?rq=1

## Compile le document en rmarkdown dans le chunk

```{r}
# your_Script_R.Rmd est le nom du fichier
rmarkdown::render("your_Script_R.Rmd", "all") 
```

## Lancer un fichier Rmd avec des arguments

### Basique

Dans le terminal mettre : 

```bash
# Ligne de commande dans le terminal
Rscript -e "rmarkdown::render('Fichier_for_Knit.Rmd', clean=TRUE)"
```

### Avec des arguments

Les `""` dans devant le `rmarkdown::render` sont **obligatoirement des guillements** alors que pour les arguments (ici A, B et C) il s'agit **obligatoirement d'apostrophes simples** !


```bash
# Ligne de commande dans le terminal
Rscript -e "rmarkdown::render('your_Script_R.Rmd', params=list(A = 'argument_files_A.csv', B = 'argument_files_B.csv', C = 'argument_files_C.csv'))"
```

L'entête du fichier `your_Script_R.Rmd` étant: 

```
---
title: "Comparaison de 2 fichiers VCFs"
author: "Votre_nom"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
params:
  A: "A"
  B: "B"
  C: "C"
---

```

De plus dans le fichier, les arguments sont appelé pour A /B et C respectivement `params$A` / `params$C` / `params$C`
